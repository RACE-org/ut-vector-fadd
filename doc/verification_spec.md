## 1 验证说明

### 1.1 向量处理器与Lane执行单元简介

RISC-V "V" (Vector) 扩展旨在通过单指令多数据（SIMD）并行处理模式，显著提升处理器在科学计算、机器学习、多媒体处理等领域的性能。向量处理器的核心思想是使用一条指令，对一组数据（即"向量"）中的所有元素执行相同的操作。

为实现高并行度，向量处理器的执行模块通常被划分为多个并行的"通道"（**Lane**）。每个Lane包含一组专用的执行单元。当执行一条向量指令时，整个向量被拆分到各个Lane中，由每个Lane的执行单元并行处理各自的数据分片。LaneFAdd 就是这样一个位于Lane内部，专门负责浮点加法相关的执行单元。

### 1.2 LaneFAdd 模块简介

本次验证的对象是LaneFAdd模块。这是一个高度复用的向量浮点运算单元，旨在以面积和效率最优的方式实现RISC-V "V"扩展中的大部分浮点指令。

该模块的核心设计思想并非为每种运算（加、减、比较、选择等）都设计独立的硬件电路，而是利用核心的浮点加法器，通过对输入操作数进行预处理（如符号位反转）、并对输出结果进行后处理（如提取符号位、判断是否为零），来实现多种复杂的浮点功能。

LaneFAdd 模块的主要特性包括：

- **数据通路（Lane）宽度**：64位，可在一个周期内并行处理 **2个32位单精度浮点**或**4个16位半精度浮点**操作。
- **流水线结构**：采用多级流水线设计，以提高工作频率和吞吐量。
- **支持多种浮点格式**：支持 **FP32 (单精度)、FP16 (半精度)** 和 **BF16** 三种浮点数据格式，通过 io.sewIn 端口的控制信号进行切换。
- **功能复用**：本模块通过复用加法器来支持以下指令：
  - **基础算术**：vfadd, vfsub, vfrsub
  - **位宽widen算术**：vfwadd, vfwsub
  - **Min/max值选择**：vfmin, vfmax
  - **符号注入**：vfsgnj, vfsgnjn, vfsgnjx
  - **比较运算**：vmfeq, vmfne, vmflt, vmfle, vmfgt, vmfge
  - **move指令**：vfmv, vfmv.s.f, vfmv.f.s

（注：本模块不支持64位双精度浮点）

### 1.3 标准文档

RVV（RISC-V Vector）1.0的specification包含对上述指令的说明，也是本向量处理器设计和验证的参考文档。
该标准的参考地址为：https://github.com/riscvarchive/riscv-v-spec/blob/master/v-spec.adoc
上述指令对应的标准中的章节为：

| 章节  | 指令                                |
| ----- | ----------------------------------- |
| 13.2  | vfadd vfsub vfrsub.vf               |
| 13.3  | vfwadd vfwsub vfwadd.w vfwsub.w     |
| 13.11 | vfmin vfmax                         |
| 13.12 | vfsgnj vfsgnjn vfsgnjx              |
| 13.13 | vmfeq vmfne vmflt vmfle vmfgt vmfge |
| 13.16 | vfmv                                |
| 16.2  | vfmv.f.s vfmv.s.f                   |

### 1.4 顶层接口

LaneFAdd 模块的顶层接口及说明如下表所示：

| **信号**           | **方向** | **位宽** | **说明**                                                                                                                                                                                                                                                                                                                                                    |
| ------------------ | -------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| clock              | Input    | 1        | 时钟信号                                                                                                                                                                                                                                                                                                                                                    |
| reset              | Input    | 1        | 复位信号                                                                                                                                                                                                                                                                                                                                                    |
| io.in.valid        | Input    | 1        | 输入请求有效信号                                                                                                                                                                                                                                                                                                                                            |
| io.in.bits.uop     | Input    | \-       | 输入的微指令 (Micro-operation)。它包含了指令执行所需的所有控制信息。对于LaneFAdd模块，uop中的大部分信号是**透明传输**的，即直接通过流水线寄存器传递到输出，供后续的写回等阶段使用。但模块会解析其中的部分关键信号作为内部运算的控制信号，例如 uopIdx (用于widen操作时选择数据)、widen (widen指令标志)、vm (掩码操作标志)等。后面会有一个**uop的展开表格**。 |
| io.in.bits.vs1     | Input    | 64       | 向量源操作数1                                                                                                                                                                                                                                                                                                                                               |
| io.in.bits.vs2     | Input    | 64       | 向量源操作数2                                                                                                                                                                                                                                                                                                                                               |
| io.in.bits.vs3     | Input    | 64       | 向量源操作数3 (本验证的所有指令**不涉及**此信号)                                                                                                                                                                                                                                                                                                            |
| io.in.bits.rs1     | Input    | 64       | 标量源操作数1                                                                                                                                                                                                                                                                                                                                               |
| io.sewIn           | Input    | 4        | 指定当前操作的数据宽度（SEW）和浮点格式。其包含一个4比特的oneHot信号，其中oneHot(0), oneHot(1), oneHot(2), oneHot(3)分别指示bf16, fp16, fp32, fp64                                                                                                                                                                                                          |
| io.out.valid       | Output   | 1        | 输出结果有效信号                                                                                                                                                                                                                                                                                                                                            |
| io.out.bits.uop    | Output   | \-       | 透传的微指令，用于写回阶段识别                                                                                                                                                                                                                                                                                                                              |
| io.out.bits.vd     | Output   | 64       | 计算结果，写入向量目标寄存器                                                                                                                                                                                                                                                                                                                                |
| io.out.bits.fflags | Output   | 4x5      | 浮点异常标志，此信号暂时忽略，**无需进行验证**                                                                                                                                                                                                                                                                                                              |
| io.rd.valid        | Output   | 1        | 标量寄存器写回有效信号，用于 vfmv.f.s                                                                                                                                                                                                                                                                                                                       |
| io.rd.bits         | Output   | 64       | vfmv.f.s 指令的结果，写入标量寄存器                                                                                                                                                                                                                                                                                                                         |

### 1.5 uop

下面是uop信号的展开。其中大部分信号都是透明传输，设成任意值都可以。
部分信号用做控制信号，将在展开表格下面的**uop的关键控制信号**小节描述。

| 信号         | 位宽                     |
| ------------ | ------------------------ |
| **ctrl**     | 一组信号，见下面展开介绍 |
| **csr**      | 一组信号，见下面展开介绍 |
| robIdx_flag  | 1                        |
| robIdx_value | 8                        |
| veewVd       | 3                        |
| uopIdx       | 3                        |
| uopEnd       | 1                        |
| lsrcUop      | 2x5                      |
| ldestUop     | 5                        |
| lsrcValUop   | 3x1                      |
| lmaskValUop  | 1                        |
| ldestValUop  | 1                        |

**ctrl**信号展开：

| 信号        | 位宽 |
| ----------- | ---- |
| lsrc        | 2x5  |
| ldest       | 5    |
| vm          | 1    |
| funct6      | 6    |
| funct3      | 3    |
| illegal     | 1    |
| lsrcVal     | 3x1  |
| ldestVal    | 1    |
| rdVal       | 1    |
| load        | 1    |
| store       | 1    |
| arith       | 1    |
| crossLane   | 1    |
| alu         | 1    |
| mul         | 1    |
| fp          | 1    |
| div         | 1    |
| fixP        | 1    |
| redu        | 1    |
| mask        | 1    |
| perm        | 1    |
| vfadd       | 1    |
| vfma        | 1    |
| vfcvt       | 1    |
| widen       | 1    |
| widen2      | 1    |
| narrow      | 1    |
| narrow_to_1 | 1    |

**csr**信号展开：

| 信号   | 位宽 |
| ------ | ---- |
| vstart | 11   |
| vl     | 12   |
| vxrm   | 2    |
| frm    | 3    |
| vlmul  | 3    |
| vsew   | 3    |
| vill   | 1    |
| ma     | 1    |
| ta     | 1    |

#### uop的关键控制信号

Uop中有用的控制信号：

- widen：vfwadd.vv, vfwadd.vf, vfwsub.vv, vfwsub.vf指令设为1
- widen2：vfwadd.wv, vfwadd.wf, vfwsub.wv, vfwsub.wf指令设为1
- uopIdx: 对于widen或者widen2指令，针对输入数据为16比特操作数的情况，如果uopIdx(0)为0，则输入的低32比特有效（包含两个16比特数据）；如果uopIdx(0)为1，则输入的高32比特有效（包含两个16比特数据）。（注：widen指令不支持输出为64比特数据的情况）
- funct6：用来区分不同的指令 （见下表：funct6编码表）
- funct3：用来区分不同的操作数类型 （见下表：funct3编码表）

**funct6编码表**

| 章节  | 指令     | funct6编码     |
| ----- | -------- | -------------- |
| 13.2  | vfadd    | 000000         |
| 13.2  | vfsub    | 000010         |
| 13.2  | vfrsub   | 100111         |
| 13.3  | vfwadd   | 110000         |
| 13.3  | vfwsub   | 110010         |
| 13.3  | vfwadd.w | 110100         |
| 13.3  | vfwsub.w | 110110         |
| 13.11 | vfmin    | 000100         |
| 13.11 | vfmax    | 000110         |
| 13.12 | vfsgnj   | 001000         |
| 13.12 | vfsgnjn  | 001001         |
| 13.12 | vfsgnjx  | 001010         |
| 13.13 | vmfeq    | 011000         |
| 13.13 | vmfne    | 011100         |
| 13.13 | vmflt    | 011011         |
| 13.13 | vmfle    | 011001         |
| 13.13 | vmfgt    | 011101         |
| 13.13 | vmfge    | 011111         |
| 13.16 | vfmv     | 010111         |
| 16.2  | vfmv.f.s | 010000 (vs1=0) |
| 16.2  | vfmv.s.f | 010000 (vs2=0) |

**funct3编码表**

| funct3 | Category | Operands         | Type of scalar operand       |
| ------ | -------- | ---------------- | ---------------------------- |
| 000    | OPIVV    | vector-vector    | N/A                          |
| 001    | OPFVV    | vector-vector    | N/A                          |
| 010    | OPMVV    | vector-vector    | N/A                          |
| 011    | OPIVI    | vector-immediate | imm[4:0]                     |
| 100    | OPIVX    | vector-scalar    | GPR x register rs1           |
| 101    | OPFVF    | vector-scalar    | FP f register rs1            |
| 110    | OPMVX    | vector-scalar    | GPR x register rs1           |
| 111    | OPCFG    | scalars-imms     | GPR x register rs1 & rs2/imm |

### 1.6 限制和约束

目前待测试DUT有如下限制，测试例应满足下面的条件：

- 浮点rounding模式只支持RNE（AI应用RNE足够）
- +0和-0我们认为是等价的（如果dut和参考模型分别为+0和-0，不应该报错）
- fflags目前无效，不需要检测
- NaN 只支持 QNaN
- 目前所有指令都不需要mask测试
- vfmin/vfmax指令，如果输入有NaN，那么结果是任意输入都对。例如: min(1, NaN)的结果可以是1或者NaN，都是正确的。
- 对于widen指令（widen或者widen2），输入的sewIn信号应该设为bf16或者fp16（而不是fp32）。

## 2 功能点和测试点

LaneFAdd 模块通过高度复用的硬件逻辑实现了多种 RISC-V 向量浮点指令。为了系统性地验证其功能的正确性和完备性，我们将模块的功能按照指令的行为特性划分为六大**功能点 (Feature)**。随后，针对每个功能点，我们进一步拆解出若干个具体的**测试点 (Test Point)**。

> [!NOTE]
> 参与者可以在此基础上补充。

下表总结了所有的功能点及其对应的测试点：

**表2-1: 功能点与测试点总览**

| **功能点**                     | **测试点**                                                                                                                      | **简述**                                                                                                                        |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **1. 基础算术功能**            | 1.1 vfadd运算正确性                                                                                                             | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例                                                                    |
| 1.2 vfsub运算正确性            | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例                                                                    |                                                                                                                                 |
| 1.3 vfrsub 运算正确性          | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例                                                                    |                                                                                                                                 |
| **2. Widen算术功能**           | 2.1 vfwadd浮点widen运算                                                                                                         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证输出数据是否被正确widen。                                   |
| 2.2 vfwsub浮点widen运算        | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证输出数据是否被正确widen。                                   |                                                                                                                                 |
| 2.3 vfwadd.wv浮点二类widen运算 | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证输出数据是否被正确widen。                                   |                                                                                                                                 |
| 2.4 vfwsub.wv浮点二类widen运算 | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证输出数据是否被正确widen。                                   |                                                                                                                                 |
| **3. 比较功能**                | 3.1 vmfeq 浮点比较指令                                                                                                          | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |
| 3.2 vmfne 浮点比较指令         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |                                                                                                                                 |
| 3.3 vmflt 浮点比较指令         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |                                                                                                                                 |
| 3.4 vmfle 浮点比较指令         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |                                                                                                                                 |
| 3.5 vmfgt 浮点比较指令         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |                                                                                                                                 |
| 3.6 vmfge 浮点比较指令         | 针对不同浮点类型(bf16/fp16/fp32)，包含随机测试例和手写测试例。需验证比较结果是否正确。同时注意与 NaN 等特殊值比较结果的正确性。 |                                                                                                                                 |
| **4. Min/max选择功能**         | 4.1 vfmax 功能正确性                                                                                                            | 验证 vfmax 指令能够正确选择两个操作数中的较大值                                                                                 |
| 4.2 vfmin 功能正确性           | 验证 vfmin 指令能够正确选择两个操作数中的较小值                                                                                 |                                                                                                                                 |
| **5. 符号注入功能**            | 5.1 vfsgnj (符号拷贝)                                                                                                           | 验证 vfsgnj 能将操作数2的符号位正确赋给操作数1                                                                                  |
| 5.2 vfsgnjn (反转符号拷贝)     | 验证 vfsgnjn 能将操作数2的反转符号位正确赋给操作数1                                                                             |                                                                                                                                 |
| 5.3 vfsgnjx (异或符号拷贝)     | 验证 vfsgnjx 能将两个操作数的符号位异或结果赋给操作数1                                                                          |                                                                                                                                 |
| **6. Move功能**                | 6.1 vfmv.f.v (标量-向量)                                                                                                        | 验证能将标量浮点寄存器值广播到向量寄存器的所有元素                                                                              |

### 2.1 功能点1: 基础算术功能

这是LaneFAdd模块最核心的功能。验证的重点在于不同数据格式和特殊数值下的计算精度和行为正确性。

- **测试点 1.1 - 1.3: vfadd, vfsub, vfrsub 运算正确性**
- **验证描述**: 分别对 vfadd (a+b), vfsub (a-b), vfrsub (b-a) 三种指令进行独立测试。每条指令都需要覆盖 bf16, fp16, fp32 三种浮点类型。测试激励应同时包含随机生成的测试例和针对边界值（如 NaN, INF, Zero 等）手写的定向测试例，确保计算结果与参照模型完全一致。

### 2.2 功能点2: Widen算术功能

Widen算术指令将两个窄位宽操作数拓宽为更宽的位宽后再进行计算。LaneFAdd 支持两种Widen模式。

- **测试点 2.1 - 2.2: vfwadd, vfwsub 浮点widen运算**
- **验证描述**: 验证第一类Widen指令 (uop.ctrl.widen)。DUT应将两个16位操作数 (vs1, vs2) 拓宽为32位，然后执行加/减法。测试需要覆盖所有浮点类型，并包含随机和手写测试例，验证输出数据是否被正确拓宽且计算结果正确。
- **测试点 2.3 - 2.4: vfwadd.wv, vfwsub.wv 浮点二类widen运算**
- **验证描述**: 验证第二类Widen指令 (uop.ctrl.widen2)。这类指令的一个操作数 (vs2) 已经是32位，另一个操作数 (vs1) 需要从16位拓宽到32位。测试需要验证这种非对称的拓宽逻辑是否正确，以及最终的计算结果是否符合预期。

### 2.3 功能点3: 比较功能

比较指令不产生浮点数值，而是生成一个"掩码"（Mask），用于后续的掩码操作。

- **测试点 3.1 - 3.6: 六种浮点比较指令**
- **验证描述**: 遍历 vmfeq (等于), vmfne (不等于), vmflt (小于), vmfle (小于等于), vmfgt (大于), vmfge (大于等于) 这六种指令。每条指令的测试都需要覆盖 bf16/fp16/fp32 类型，并通过随机和定向测试例，验证输出的掩码是否正确。**特别注意**：需要构造操作数包含NaN的测试用例，验证其比较结果是否符合RISC-V规范（例如，与NaN的任何比较，除vmfne外，结果都应为false）。

### 2.4 功能点4: Min/max选择功能

vfmin 和 vfmax 指令在两个输入向量的对应元素之间选择较小或较大的一个作为结果。

- **测试点 4.1: vfmax 功能正确性**
- **验证描述**: 验证 vfmax 指令能够正确选择两个操作数中的较大值。测试需覆盖普通数值、特殊值（NaN, INF等）的场景。
- **测试点 4.2: vfmin 功能正确性**
- **验证描述**: 验证 vfmin 指令能够正确选择两个操作数中的较小值。测试需覆盖普通数值、特殊值（NaN, INF等）的场景。
- **注**：vfmin/vfmax指令，如果输入有NaN，那么结果是任意输入都对。例如: min(1, NaN)的结果可以是1或者NaN，都是正确的。

### 2.5 功能点5: 符号注入功能

符号注入指令用于根据不同规则，操控操作数的符号位，而不改变其指数和尾数。

- **测试点 5.1: vfsgnj (符号拷贝)**
- **验证描述**: 验证 vfsgnj 能将操作数2的符号位正确赋给操作数1，生成新的浮点数。
- **测试点 5.2: vfsgnjn (反转符号拷贝)**
- **验证描述**: 验证 vfsgnjn 能将操作数2的**反转**符号位正确赋给操作数1。
- **测试点 5.3: vfsgnjx (异或符号拷贝)**
- **验证描述**: 验证 vfsgnjx 能将两个操作数的符号位**异或**后的结果赋给操作数1。

### 2.6 功能点6: Move功能

数据传送指令在向量寄存器和标量寄存器之间移动数据。

- **测试点 6.1: vfmv.f.v (标量-向量)**
- **验证描述**: 验证 vfmv.f.v (RISC-V标准中的vfmv.v.f) 能将一个标量浮点寄存器的值（来自rs1）正确地广播到目标向量寄存器的所有元素中。

## 3 测试用例

为了系统性地覆盖在第三章中定义的所有功能点和测试点，我们设计了以下6个测试用例。其中，前5个是**定向测试用例**，分别专注于基础算术、widen运算、比较与选择、符号与move等核心功能。第6个是**随机压力测试用例**，旨在通过大量随机激励发现定向测试中可能遗漏的边界和组合逻辑缺陷。

所有测试用例都内置了对计算结果正确性的基本检查，因此均覆盖了"结果与参照模型一致"这一基础要求。

> [!NOTE]
> 参与者可以在此基础上补充。

**表3-1: 功能点、测试点与测试用例的对应关系**

| **功能点**           | **测试点**                   | **测试用例**            |
| -------------------- | ---------------------------- | ----------------------- |
| 1\. 基础算术         | 1.1, 1.2, 1.3                | TC1: 基础算术测试       |
| 2\. Widen算术        | 2.1, 2.2, 2.3, 2.4           | TC2: Widen算术测试      |
| 3\. 比较功能         | 3.1, 3.2, 3.3, 3.4, 3.5, 3.6 | TC3: 比较功能测试       |
| 4.Min/max功能        | 4.1, 4.2                     | TC4: Min/max测试        |
| 5.符号注入与move功能 | 5.1, 5.2, 5.3, 6.1           | TC5: 符号注入与move测试 |
| 6\. 所有功能         | 所有测试点                   | TC6: 随机压力测试       |

### 3.1 测试用例1: 基础算术测试

该用例是验证 LaneFAdd 模块核心加减法功能，重点验证其在不同数据格式下的计算精度，以及对浮点标准中特殊值的处理能力。

| 用例                                                                                                                                                                                                                                                                                                                                                   | 目标功能点                                  | 运行方法 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------- | -------- |
| 测试用例1                                                                                                                                                                                                                                                                                                                                              | 测试点1.1<br><br>测试点1.2<br><br>测试点1.3 |          |
| 用例说明<br><br>**1**: 遍历 vfadd, vfsub, vfrsub 三种指令。 <br>**2**: 对每种指令，遍历 FP32, FP16, BFloat16 三种数据格式。 <br>**3**: 对每种组合，使用一组预定义的、覆盖全面的定向操作数进行激励，包括： <br> - 普通数值（正、负、大小不同的组合） <br> - 正负零 (+0, -0) <br> - 正负无穷 (+INF, -INF) <br> - NaN (QNaN) <br> - 非规格化数 (Denormal) |                                             |          |
| 预期结果<br><br>测试点1.1：结果与参考模型一致<br><br>测试点1.2：结果与参考模型一致<br><br>测试点1.3：结果与参考模型一致                                                                                                                                                                                                                                |                                             |          |

### 3.2 测试用例2: Widen算术测试

该用例专注于验证Widen指令（如 vfwadd）的正确性，核心是验证16位操作数到32位操作数的选择、扩展和计算逻辑。

| 用例                                                                                                                                                                                                                                                                                                       | 目标功能点                                                   | 运行方法 |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 测试用例2                                                                                                                                                                                                                                                                                                  | 测试点2.1<br><br>测试点2.2<br><br>测试点2.3<br><br>测试点2.4 |          |
| 用例说明<br><br>**1**: 构造 vfwadd 和 vfwsub 指令激励，确保 uop.ctrl.widen 或 uop.ctrl.widen2 信号有效。 <br>**2**: 对于普通widen指令，输入数据为FP16, BFloat16 两种格式。对于wv指令，注意其中一个输入数据为FP32格式。 <br>**3**: 改变 uop.uopIdx 的值（0或1），以测试对输入向量高、低32位部分的选择逻辑。 |                                                              |          |
| 预期结果<br><br>测试点2.1：结果与参考模型一致<br><br>测试点2.2：结果与参考模型一致<br><br>测试点2.3：结果与参考模型一致<br><br>测试点2.4：结果与参考模型一致                                                                                                                                               |                                                              |          |

### 3.3 测试用例3: 比较功能测试

该用例为比较功能测试，用于测试6条向量浮点compare指令。

| 用例                                                                                                                                                                                                                                                      | 目标功能点                                                                                     | 运行方法 |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | -------- |
| 测试用例3                                                                                                                                                                                                                                                 | 测试点3.1<br><br>测试点3.2<br><br>测试点3.3<br><br>测试点3.4<br><br>测试点3.5<br><br>测试点3.6 |          |
| 用例说明<br><br>**1**: 遍历 vmfeq, vmfne, vmflt, vmfle, vmfgt, vmfge所有6种指令。 <br>**2**: 对每种指令，在16位和32位模式下，分别构造使比较结果为真和为假的操作数对 (a > b, a < b, a == b) <br>**3**: 专门构造包含 NaN 的操作数对，以测试特殊值处理逻辑。 |                                                                                                |          |
| 预期结果<br><br>对于比较指令，io.out.bits.vd 的输出必须是正确的掩码（相应位为1或0）。与NaN的比较，除vmfne外，结果必须为0                                                                                                                                  |                                                                                                |          |

### 3.4 测试用例4: Min/max选择功能

该用例测试最大最小值选择功能。

| 用例                                                                                                               | 目标功能点                 | 运行方法 |
| ------------------------------------------------------------------------------------------------------------------ | -------------------------- | -------- |
| 测试用例4                                                                                                          | 测试点4.1<br><br>测试点4.2 |          |
| 用例说明<br><br>**1**: 遍历 vfmax, vfmin两种指令。 <br>**2**: 对每种指令，遍历 FP32, FP16, BFloat16 三种数据格式。 |                            |          |
| 预期结果<br><br>测试点4.1：结果与参考模型一致<br><br>测试点4.2：结果与参考模型一致                                 |                            |          |

### 3.5 测试用例5: 符号注入与move测试

该用例验证与数值计算无关的数据处理类指令，包括符号位操作和寄存器间的数据移动。

| 用例                                                                                                                                                                                               | 目标功能点                                                 | 运行方法 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | -------- |
| 测试用例5                                                                                                                                                                                          | 测试点5.1<br><br>测试点5.2<br><br>测试点5.3<br><br>测试点6 |          |
| 用例说明<br><br>**1**: 遍历 vfsgnj, vfsgnjn, vfsgnjx 指令，并对 vs1 和 vs2 的符号进行所有四种组合（+/+, +/-, -/+, -/-）。 <br>**2**: 发送 vfmv.f.v 指令，并提供一个标量值 rs1。                    |                                                            |          |
| 预期结果<br><br>1: 测试点5.1-5.3：io.out.bits.vd 的符号位必须符合 sgnj/sgnjn/sgnjx 的逻辑规则，而指数和尾数部分应保持与 vs1 一致。<br><br>2: 测试点6：io.out.bits.vd 的每个元素都应等于 rs1 的值。 |                                                            |          |

### 3.6 测试用例6: 随机压力测试

该用例通过长时间、大规模的随机激励，对 LaneFAdd 进行全面的压力测试

| 用例                                                                                                                                                                                                                                                                                               | 目标功能点 | 运行方法 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- | -------- |
| 测试用例6                                                                                                                                                                                                                                                                                          | 全部测试点 |          |
| 用例说明<br><br>**1**: 在一个循环中执行大量（例如 10,000 次）随机事务。<br><br>**2**: 在每次事务中，随机选择一个 LaneFAdd 支持的指令。<br><br>3: 随机选择数据格式（FP32, FP16, BFloat16）<br><br>4: 根据约束随机生成操作数 vs1, vs2, rs1。生成器会以一定概率产生特殊值（NaN, INF, Zero, Denormal） |            |          |
| 预期结果<br><br>与参考模式一致                                                                                                                                                                                                                                                                     |            |          |
